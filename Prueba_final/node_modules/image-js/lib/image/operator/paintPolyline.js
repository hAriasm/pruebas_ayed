'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = paintPolyline;

/**
 * Paint a polyline defined by an array of points.
 * @memberof Image
 * @instance
 * @param {Array<Array<number>>} points - Array of [x,y] points
 * @param {object} [options]
 * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.
 * @param {boolean} [options.closed=false] - Close the polyline.
 * @return {this} The original painted image
 */
function paintPolyline(points, options = {}) {
    var _options$color = options.color,
        color = _options$color === undefined ? [this.maxValue, 0, 0] : _options$color,
        _options$closed = options.closed,
        closed = _options$closed === undefined ? false : _options$closed;


    this.checkProcessable('paintPoints', {
        bitDepth: [8, 16]
    });

    var numberChannels = Math.min(this.channels, color.length);

    for (var i = 0; i < points.length - 1 + closed; i++) {
        var from = points[i];
        var to = points[(i + 1) % points.length];

        var dx = to[0] - from[0];
        var dy = to[1] - from[1];
        var steps = Math.max(Math.abs(dx), Math.abs(dy));

        var xIncrement = dx / steps;
        var yIncrement = dy / steps;

        var x = from[0];
        var y = from[1];

        for (var j = 0; j <= steps; j++) {
            var xPoint = Math.round(x);
            var yPoint = Math.round(y);

            if (xPoint >= 0 && yPoint >= 0 && xPoint < this.width && yPoint < this.height) {
                var position = (xPoint + yPoint * this.width) * this.channels;
                for (var channel = 0; channel < numberChannels; channel++) {
                    this.data[position + channel] = color[channel];
                }
            }

            x = x + xIncrement;
            y = y + yIncrement;
        }
    }

    return this;
}