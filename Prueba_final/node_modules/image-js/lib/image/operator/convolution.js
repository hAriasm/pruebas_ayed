'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = convolution;

var _mlMatrixConvolution = require('ml-matrix-convolution');

var _Image = require('../Image');

var _Image2 = _interopRequireDefault(_Image);

var _channel = require('../../util/channel');

var _kernel = require('../../util/kernel');

var _convolutionSeparable = require('../operator/convolutionSeparable');

var _convolutionSeparable2 = _interopRequireDefault(_convolutionSeparable);

var _getSeparatedKernel = require('./getSeparatedKernel');

var _getSeparatedKernel2 = _interopRequireDefault(_getSeparatedKernel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @memberof Image
 * @instance
 * @param {Array<Array<number>>} kernel
 * @param {object} [options] - options
 * @param {Array} [options.channels] - Array of channels to treat. Defaults to all channels
 * @param {number} [options.bitDepth=this.bitDepth] - A new bit depth can be specified. This allows to use 32 bits to avoid clamping of floating-point numbers.
 * @param {boolean} [options.normalize=false]
 * @param {number} [options.divisor=1]
 * @param {string} [options.border='copy']
 * @param {string} [options.algorithm='auto'] - Either 'auto', 'direct', 'fft' or 'separable'. fft is much faster for large kernel.
 * If the separable algorithm is used, one must provide as kernel an array of two 1D kernels.
 * The 'auto' option will try to separate the kernel if that is possible.
 * @return {Image}
 */
function convolution(kernel, options = {}) {
    var channels = options.channels,
        bitDepth = options.bitDepth,
        _options$normalize = options.normalize,
        normalize = _options$normalize === undefined ? false : _options$normalize,
        _options$divisor = options.divisor,
        divisor = _options$divisor === undefined ? 1 : _options$divisor,
        _options$border = options.border,
        border = _options$border === undefined ? 'copy' : _options$border,
        _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'auto' : _options$algorithm;


    var newImage = _Image2.default.createFrom(this, { bitDepth });

    channels = (0, _channel.validateArrayOfChannels)(this, channels, true);

    if (algorithm !== 'separable') {
        var _validateKernel = (0, _kernel.validateKernel)(kernel);

        kernel = _validateKernel.kernel;
    } else if (!Array.isArray(kernel) || kernel.length !== 2) {
        throw new RangeError('separable convolution requires two arrays of numbers to represent the kernel');
    }

    if (algorithm === 'auto') {
        var separatedKernel = (0, _getSeparatedKernel2.default)(kernel);
        if (separatedKernel !== null) {
            algorithm = 'separable';
            kernel = separatedKernel;
        } else if ((kernel.length > 9 || kernel[0].length > 9) && this.width <= 4096 && this.height <= 4096) {
            algorithm = 'fft';
        } else {
            algorithm = 'direct';
        }
    }

    var halfHeight = void 0,
        halfWidth = void 0;
    if (algorithm === 'separable') {
        halfHeight = Math.floor(kernel[0].length / 2);
        halfWidth = Math.floor(kernel[1].length / 2);
    } else {
        halfHeight = Math.floor(kernel.length / 2);
        halfWidth = Math.floor(kernel[0].length / 2);
    }
    var clamped = newImage.isClamped;

    var tmpData = new Array(this.height * this.width);
    var index = void 0,
        x = void 0,
        y = void 0,
        channel = void 0,
        c = void 0,
        tmpResult = void 0;
    for (channel = 0; channel < channels.length; channel++) {
        c = channels[channel];
        //Copy the channel in a single array
        for (y = 0; y < this.height; y++) {
            for (x = 0; x < this.width; x++) {
                index = y * this.width + x;
                tmpData[index] = this.data[index * this.channels + c];
            }
        }
        if (algorithm === 'direct') {
            tmpResult = (0, _mlMatrixConvolution.direct)(tmpData, kernel, {
                rows: this.height,
                cols: this.width,
                normalize: normalize,
                divisor: divisor
            });
        } else if (algorithm === 'separable') {
            tmpResult = (0, _convolutionSeparable2.default)(tmpData, kernel, this.width, this.height);
            if (normalize) {
                divisor = 0;
                for (var i = 0; i < kernel[0].length; i++) {
                    for (var j = 0; j < kernel[1].length; j++) {
                        divisor += kernel[0][i] * kernel[1][j];
                    }
                }
            }
            if (divisor !== 1) {
                for (var _i = 0; _i < tmpResult.length; _i++) {
                    tmpResult[_i] /= divisor;
                }
            }
        } else {
            tmpResult = (0, _mlMatrixConvolution.fft)(tmpData, kernel, {
                rows: this.height,
                cols: this.width,
                normalize: normalize,
                divisor: divisor
            });
        }

        //Copy the result to the output image
        for (y = 0; y < this.height; y++) {
            for (x = 0; x < this.width; x++) {
                index = y * this.width + x;
                if (clamped) {
                    newImage.data[index * this.channels + c] = Math.min(Math.max(tmpResult[index], 0), newImage.maxValue);
                } else {
                    newImage.data[index * this.channels + c] = tmpResult[index];
                }
            }
        }
    }
    // if the kernel was not applied on the alpha channel we just copy it
    // TODO: in general we should copy the channels that where not changed
    // TODO: probably we should just copy the image at the beginning ?
    if (this.alpha && !channels.includes(this.channels)) {
        for (x = this.components; x < this.data.length; x = x + this.channels) {
            newImage.data[x] = this.data[x];
        }
    }

    //I only can have 3 types of borders:
    //  1. Considering the image as periodic: periodic
    //  2. Extend the interior borders: copy
    //  3. fill with a color: set
    if (border !== 'periodic') {
        newImage.setBorder({ size: [halfWidth, halfHeight], algorithm: border });
    }

    return newImage;
}