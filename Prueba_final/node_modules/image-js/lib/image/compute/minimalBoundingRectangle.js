'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = minimalBoundingRectangle;

var _monotoneChainConvexHull = require('./monotoneChainConvexHull');

var _monotoneChainConvexHull2 = _interopRequireDefault(_monotoneChainConvexHull);

var _points = require('../../util/points');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Computes the minimum bounding box around a binary image
 * https://www.researchgate.net/profile/Lennert_Den_Boer2/publication/303783472_A_Fast_Algorithm_for_Generating_a_Minimal_Bounding_Rectangle/links/5751a14108ae6807fafb2aa5.pdf
 * @memberof Image
 * @instance
 * @param {object} [options]
 * @param {Array<Array<number>>} [options.originalPoints]
 * @return {Array<Array<number>>}
 */
function minimalBoundingRectangle(options = {}) {
    var _options$originalPoin = options.originalPoints,
        originalPoints = _options$originalPoin === undefined ? _monotoneChainConvexHull2.default.call(this) : _options$originalPoin;


    if (originalPoints.length === 0) {
        return [];
    }

    if (originalPoints.length === 1) {
        return [originalPoints[0], originalPoints[0], originalPoints[0], originalPoints[0]];
    }

    var p = new Array(originalPoints.length);

    var minSurface = +Infinity;
    var minSurfaceAngle = 0;
    var mbr = void 0;

    for (var i = 0; i < p.length; i++) {
        var angle = getAngle(originalPoints[i], originalPoints[(i + 1) % p.length]);

        (0, _points.rotate)(-angle, originalPoints, p);

        // we rotate and translate so that this axe is in the bottom
        var aX = p[i][0];
        var aY = p[i][1];
        var bX = p[(i + 1) % p.length][0];
        var bY = p[(i + 1) % p.length][1];

        var tUndefined = true;
        var tMin = 0;
        var tMax = 0;
        var maxWidth = 0;
        for (var j = 0; j < p.length; j++) {
            var cX = p[j][0];
            var cY = p[j][1];
            var t = (cX - aX) / (bX - aX);
            if (tUndefined === true) {
                tUndefined = false;
                tMin = t;
                tMax = t;
            } else {
                if (t < tMin) tMin = t;
                if (t > tMax) tMax = t;
            }
            var width = (-(bX - aX) * cY + bX * aY - bY * aX) / (bX - aX);

            if (Math.abs(width) > Math.abs(maxWidth)) maxWidth = width;
        }
        var pMin = [aX + tMin * (bX - aX), aY];
        var pMax = [aX + tMax * (bX - aX), aY];

        var currentSurface = Math.abs(maxWidth * (tMin - tMax) * (bX - aX));

        if (currentSurface < minSurface) {
            minSurfaceAngle = angle;
            minSurface = currentSurface;
            mbr = [pMin, pMax, [pMax[0], pMax[1] - maxWidth], [pMin[0], pMin[1] - maxWidth]];
        }
    }
    (0, _points.rotate)(minSurfaceAngle, mbr, mbr);
    return mbr;
}

// the angle that allows to make the line going through p1 and p2 horizontal
// this is an optimized version because it assume one vector is horizontal
function getAngle(p1, p2) {
    var diff = (0, _points.difference)(p2, p1);
    var vector = (0, _points.normalize)(diff);
    var angle = Math.acos(vector[0]);
    if (vector[1] < 0) return -angle;
    return angle;
}