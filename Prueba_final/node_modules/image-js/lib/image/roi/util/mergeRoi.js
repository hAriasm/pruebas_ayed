'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = mergeRoi;

/**
 * In place modification of the roiMap that joins regions of interest
 * @param {object} [options]
 * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.
 *      Current implemented algorithms are 'commonBorderLength' that use the parameters
 *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses
 *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.
 * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging
 * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging
 * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging
 * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging
 * @return {this}
 */

function mergeRoi(options = {}) {
    var _options$algorithm = options.algorithm,
        algorithm = _options$algorithm === undefined ? 'commonBorderLength' : _options$algorithm,
        _options$minCommonBor = options.minCommonBorderLength,
        minCommonBorderLength = _options$minCommonBor === undefined ? 5 : _options$minCommonBor,
        _options$maxCommonBor = options.maxCommonBorderLength,
        maxCommonBorderLength = _options$maxCommonBor === undefined ? 100 : _options$maxCommonBor,
        _options$minCommonBor2 = options.minCommonBorderRatio,
        minCommonBorderRatio = _options$minCommonBor2 === undefined ? 0.3 : _options$minCommonBor2,
        _options$maxCommonBor2 = options.maxCommonBorderRatio,
        maxCommonBorderRatio = _options$maxCommonBor2 === undefined ? 1 : _options$maxCommonBor2;


    var checkFunction = function checkFunction(currentInfo, currentID, neighbourID) {
        return currentInfo[neighbourID] >= minCommonBorderLength && currentInfo[neighbourID] <= maxCommonBorderLength;
    };
    if (typeof algorithm === 'function') {
        checkFunction = algorithm;
    }
    if (algorithm.toLowerCase() === 'commonborderratio') {
        checkFunction = function checkFunction(currentInfo, currentID, neighbourID) {
            var ratio = Math.min(currentInfo[neighbourID] / currentInfo[currentID], 1);
            return ratio >= minCommonBorderRatio && ratio <= maxCommonBorderRatio;
        };
    }
    var roiMap = this;
    var borderLengths = roiMap.commonBorderLength;
    var newMap = {};
    var oldToNew = {};

    for (var currentID of Object.keys(borderLengths)) {
        var currentInfo = borderLengths[currentID];
        var neighbourIDs = Object.keys(currentInfo);
        for (var neighbourID of neighbourIDs) {
            if (neighbourID !== currentID) {
                // it is not myself ...
                if (checkFunction(currentInfo, currentID, neighbourID)) {
                    // the common border are in the range. We should merge
                    var newNeighbourID = neighbourID;
                    if (oldToNew[neighbourID]) newNeighbourID = oldToNew[neighbourID];
                    var newCurrentID = currentID;
                    if (oldToNew[currentID]) newCurrentID = oldToNew[currentID];

                    if (Number(newNeighbourID) !== newCurrentID) {
                        var smallerID = Math.min(newNeighbourID, newCurrentID);
                        var largerID = Math.max(newNeighbourID, newCurrentID);

                        if (!newMap[smallerID]) {
                            newMap[smallerID] = {};
                        }
                        newMap[smallerID][largerID] = true;
                        oldToNew[largerID] = smallerID;
                        if (newMap[largerID]) {
                            // need to put everything to smallerID and remove property
                            for (var id of Object.keys(newMap[largerID])) {
                                newMap[smallerID][id] = true;
                                oldToNew[id] = smallerID;
                            }
                            delete newMap[largerID];
                        }
                    }
                }
            }
        }
    }

    var minMax = roiMap.minMax;
    var shift = -minMax.min;
    var max = minMax.max + shift;
    var oldToNewArray = new Array(max + 1).fill(0);
    for (var key of Object.keys(oldToNew)) {
        oldToNewArray[Number(key) + shift] = oldToNew[key];
    }
    // time to change the roiMap
    var data = roiMap.data;
    for (var i = 0; i < data.length; i++) {
        var currentValue = data[i];
        if (currentValue !== 0) {
            var newValue = oldToNewArray[currentValue + shift];
            if (newValue !== 0) {
                data[i] = newValue;
            }
        }
    }

    roiMap.computed = {};
    return roiMap;
}